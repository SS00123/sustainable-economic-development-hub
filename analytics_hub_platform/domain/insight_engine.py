"""
Insight Engine Module
Sustainable Economic Development Analytics Hub

Provides automated insight generation by combining:
- Pattern recognition results
- Anomaly detection
- Trend analysis
- Forecasting predictions
- KPI target comparisons

Generates prioritized, actionable insights with natural language summaries.
"""

import logging
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from typing import Any

import pandas as pd

from analytics_hub_platform.domain.advanced_analytics import (
    PatternRecognitionResult,
    TrendDirection,
    SeasonalityType,
    analyze_patterns,
)
from analytics_hub_platform.domain.ml_services import (
    AnomalySeverity,
    AnomalyResult,
    detect_kpi_anomalies,
)

logger = logging.getLogger(__name__)


# =============================================================================
# ENUMS AND MODELS
# =============================================================================


class InsightType(str, Enum):
    """Type of insight generated."""

    TREND = "trend"
    ANOMALY = "anomaly"
    SEASONALITY = "seasonality"
    CHANGE_POINT = "change_point"
    TARGET_GAP = "target_gap"
    FORECAST = "forecast"
    COMPARISON = "comparison"
    MILESTONE = "milestone"


class InsightPriority(str, Enum):
    """Priority level for insights."""

    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class InsightCategory(str, Enum):
    """Category of insight (Vision 2030 pillars)."""

    ECONOMIC = "economic"
    ENVIRONMENTAL = "environmental"
    SOCIAL = "social"
    GOVERNANCE = "governance"


@dataclass
class Insight:
    """A single insight generated by the engine."""

    id: str
    type: InsightType
    priority: InsightPriority
    category: InsightCategory
    title: str
    description: str
    kpi_id: str
    region_id: str | None
    metric_value: float | None
    metric_change: float | None
    confidence: float
    generated_at: datetime
    metadata: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "id": self.id,
            "type": self.type.value,
            "priority": self.priority.value,
            "category": self.category.value,
            "title": self.title,
            "description": self.description,
            "kpi_id": self.kpi_id,
            "region_id": self.region_id,
            "metric_value": self.metric_value,
            "metric_change": self.metric_change,
            "confidence": self.confidence,
            "generated_at": self.generated_at.isoformat(),
            "metadata": self.metadata,
        }


@dataclass
class InsightReport:
    """Complete insight report for a period."""

    period: str
    generated_at: datetime
    insights: list[Insight]
    summary: str
    total_count: int
    by_priority: dict[str, int]
    by_type: dict[str, int]
    by_category: dict[str, int]

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "period": self.period,
            "generated_at": self.generated_at.isoformat(),
            "insights": [i.to_dict() for i in self.insights],
            "summary": self.summary,
            "total_count": self.total_count,
            "by_priority": self.by_priority,
            "by_type": self.by_type,
            "by_category": self.by_category,
        }


# =============================================================================
# INSIGHT GENERATORS
# =============================================================================


class TrendInsightGenerator:
    """Generates insights from trend analysis."""

    def __init__(self, significant_change_threshold: float = 10.0):
        self.significant_change_threshold = significant_change_threshold

    def generate(
        self,
        kpi_id: str,
        kpi_name: str,
        category: InsightCategory,
        pattern_result: PatternRecognitionResult,
        region_id: str | None = None,
    ) -> list[Insight]:
        """Generate trend-based insights."""
        insights = []
        trend = pattern_result.trend

        # Skip if no significant trend
        if trend.direction == TrendDirection.STABLE:
            return insights

        # Determine priority based on magnitude and confidence
        if abs(trend.total_change_pct) > 20 and trend.confidence > 0.7:
            priority = InsightPriority.HIGH
        elif abs(trend.total_change_pct) > self.significant_change_threshold:
            priority = InsightPriority.MEDIUM
        else:
            priority = InsightPriority.LOW

        # Generate insight based on direction
        if trend.direction == TrendDirection.INCREASING:
            title = f"{kpi_name}: Strong Upward Trend"
            description = (
                f"{kpi_name} shows a consistent upward trend with "
                f"{trend.total_change_pct:+.1f}% total change. "
                f"{trend.interpretation}"
            )
        elif trend.direction == TrendDirection.DECREASING:
            title = f"{kpi_name}: Declining Trend Detected"
            description = (
                f"{kpi_name} shows a declining trend with "
                f"{trend.total_change_pct:+.1f}% total change. "
                f"{trend.interpretation}"
            )
        else:  # VOLATILE
            title = f"{kpi_name}: High Volatility"
            priority = InsightPriority.MEDIUM
            description = (
                f"{kpi_name} exhibits high volatility without a clear directional trend. "
                f"Consider investigating underlying factors."
            )

        insights.append(
            Insight(
                id=f"trend_{kpi_id}_{datetime.now(timezone.utc).strftime('%Y%m%d%H%M%S')}",
                type=InsightType.TREND,
                priority=priority,
                category=category,
                title=title,
                description=description,
                kpi_id=kpi_id,
                region_id=region_id,
                metric_value=trend.end_value,
                metric_change=trend.total_change_pct,
                confidence=trend.confidence,
                generated_at=datetime.now(timezone.utc),
                metadata={
                    "slope": trend.slope,
                    "r_squared": trend.r_squared,
                    "p_value": trend.p_value,
                    "annual_change_rate": trend.annual_change_rate,
                },
            )
        )

        return insights


class AnomalyInsightGenerator:
    """Generates insights from anomaly detection."""

    def generate(
        self,
        kpi_id: str,
        kpi_name: str,
        category: InsightCategory,
        anomalies: list[AnomalyResult],
        region_id: str | None = None,
    ) -> list[Insight]:
        """Generate anomaly-based insights."""
        insights = []

        for anomaly in anomalies:
            # Map anomaly severity to insight priority
            if anomaly.severity == AnomalySeverity.CRITICAL:
                priority = InsightPriority.CRITICAL
            elif anomaly.severity == AnomalySeverity.WARNING:
                priority = InsightPriority.HIGH
            else:
                priority = InsightPriority.MEDIUM

            direction_word = "above" if anomaly.direction == "high" else "below"

            title = f"{kpi_name}: Anomaly in {anomaly.year} Q{anomaly.quarter}"
            description = (
                f"Unusual value detected for {kpi_name}: {anomaly.actual_value:.2f} "
                f"({direction_word} expected value of {anomaly.expected_value:.2f}). "
                f"Z-score: {anomaly.z_score:.2f}. {anomaly.description}"
            )

            insights.append(
                Insight(
                    id=f"anomaly_{kpi_id}_{anomaly.year}Q{anomaly.quarter}",
                    type=InsightType.ANOMALY,
                    priority=priority,
                    category=category,
                    title=title,
                    description=description,
                    kpi_id=kpi_id,
                    region_id=region_id or anomaly.region_id,
                    metric_value=anomaly.actual_value,
                    metric_change=anomaly.deviation,
                    confidence=min(1.0, abs(anomaly.z_score) / 5),
                    generated_at=datetime.now(timezone.utc),
                    metadata={
                        "z_score": anomaly.z_score,
                        "expected_value": anomaly.expected_value,
                        "year": anomaly.year,
                        "quarter": anomaly.quarter,
                    },
                )
            )

        return insights


class SeasonalityInsightGenerator:
    """Generates insights from seasonality analysis."""

    def generate(
        self,
        kpi_id: str,
        kpi_name: str,
        category: InsightCategory,
        pattern_result: PatternRecognitionResult,
        region_id: str | None = None,
    ) -> list[Insight]:
        """Generate seasonality-based insights."""
        insights = []
        seasonality = pattern_result.seasonality

        # Only generate if seasonality detected
        if seasonality.type == SeasonalityType.NONE:
            return insights

        # Priority based on strength
        if seasonality.strength > 0.3:
            priority = InsightPriority.MEDIUM
        else:
            priority = InsightPriority.LOW

        quarter_names = {1: "Q1 (Jan-Mar)", 2: "Q2 (Apr-Jun)", 3: "Q3 (Jul-Sep)", 4: "Q4 (Oct-Dec)"}

        title = f"{kpi_name}: Seasonal Pattern Identified"
        description = (
            f"{kpi_name} exhibits a quarterly seasonal pattern. "
            f"Peak performance typically occurs in {quarter_names.get(seasonality.peak_quarter, 'N/A')}, "
            f"while the lowest values are seen in {quarter_names.get(seasonality.trough_quarter, 'N/A')}. "
            f"{seasonality.interpretation}"
        )

        insights.append(
            Insight(
                id=f"seasonal_{kpi_id}_{datetime.now(timezone.utc).strftime('%Y%m%d')}",
                type=InsightType.SEASONALITY,
                priority=priority,
                category=category,
                title=title,
                description=description,
                kpi_id=kpi_id,
                region_id=region_id,
                metric_value=None,
                metric_change=None,
                confidence=seasonality.strength,
                generated_at=datetime.now(timezone.utc),
                metadata={
                    "peak_quarter": seasonality.peak_quarter,
                    "trough_quarter": seasonality.trough_quarter,
                    "quarterly_indices": seasonality.quarterly_indices,
                },
            )
        )

        return insights


class ChangePointInsightGenerator:
    """Generates insights from change point detection."""

    def generate(
        self,
        kpi_id: str,
        kpi_name: str,
        category: InsightCategory,
        pattern_result: PatternRecognitionResult,
        region_id: str | None = None,
    ) -> list[Insight]:
        """Generate change point insights."""
        insights = []

        for cp in pattern_result.change_points:
            # Priority based on magnitude and confidence
            if cp.confidence > 0.8 and abs(cp.magnitude) > cp.before_mean * 0.2:
                priority = InsightPriority.HIGH
            elif cp.confidence > 0.5:
                priority = InsightPriority.MEDIUM
            else:
                priority = InsightPriority.LOW

            title = f"{kpi_name}: Structural Change in {cp.year} Q{cp.quarter}"
            description = cp.description

            insights.append(
                Insight(
                    id=f"changepoint_{kpi_id}_{cp.year}Q{cp.quarter}",
                    type=InsightType.CHANGE_POINT,
                    priority=priority,
                    category=category,
                    title=title,
                    description=description,
                    kpi_id=kpi_id,
                    region_id=region_id,
                    metric_value=cp.after_mean,
                    metric_change=cp.magnitude,
                    confidence=cp.confidence,
                    generated_at=datetime.now(timezone.utc),
                    metadata={
                        "before_mean": cp.before_mean,
                        "after_mean": cp.after_mean,
                        "year": cp.year,
                        "quarter": cp.quarter,
                    },
                )
            )

        return insights


class TargetGapInsightGenerator:
    """Generates insights from target comparison."""

    def generate(
        self,
        kpi_id: str,
        kpi_name: str,
        category: InsightCategory,
        current_value: float,
        target_value: float,
        higher_is_better: bool = True,
        region_id: str | None = None,
    ) -> list[Insight]:
        """Generate target gap insights."""
        insights = []

        if target_value == 0:
            return insights

        gap_pct = ((current_value - target_value) / target_value) * 100
        gap_abs = current_value - target_value

        # Determine if on track
        if higher_is_better:
            on_track = current_value >= target_value
        else:
            on_track = current_value <= target_value

        # Determine priority
        gap_magnitude = abs(gap_pct)
        if not on_track and gap_magnitude > 20:
            priority = InsightPriority.CRITICAL
        elif not on_track and gap_magnitude > 10:
            priority = InsightPriority.HIGH
        elif not on_track:
            priority = InsightPriority.MEDIUM
        elif gap_magnitude > 10:
            priority = InsightPriority.LOW  # Exceeding target
        else:
            return insights  # Close to target, no insight needed

        if on_track:
            title = f"{kpi_name}: Exceeding Target"
            description = (
                f"{kpi_name} is currently at {current_value:.2f}, "
                f"which is {abs(gap_pct):.1f}% {'above' if higher_is_better else 'below'} "
                f"the target of {target_value:.2f}. Excellent progress."
            )
        else:
            title = f"{kpi_name}: Below Target"
            description = (
                f"{kpi_name} is currently at {current_value:.2f}, "
                f"which is {abs(gap_pct):.1f}% {'below' if higher_is_better else 'above'} "
                f"the target of {target_value:.2f}. Action may be required."
            )

        insights.append(
            Insight(
                id=f"target_{kpi_id}_{datetime.now(timezone.utc).strftime('%Y%m%d')}",
                type=InsightType.TARGET_GAP,
                priority=priority,
                category=category,
                title=title,
                description=description,
                kpi_id=kpi_id,
                region_id=region_id,
                metric_value=current_value,
                metric_change=gap_pct,
                confidence=1.0,  # Target comparison is exact
                generated_at=datetime.now(timezone.utc),
                metadata={
                    "target_value": target_value,
                    "gap_absolute": gap_abs,
                    "gap_percentage": gap_pct,
                    "on_track": on_track,
                },
            )
        )

        return insights


class MilestoneInsightGenerator:
    """Generates insights when milestones are reached."""

    def __init__(self, milestones: list[float] | None = None):
        self.milestones = milestones or [100, 500, 1000, 5000, 10000]

    def generate(
        self,
        kpi_id: str,
        kpi_name: str,
        category: InsightCategory,
        current_value: float,
        previous_value: float | None,
        region_id: str | None = None,
    ) -> list[Insight]:
        """Generate milestone insights."""
        insights = []

        if previous_value is None:
            return insights

        for milestone in self.milestones:
            # Check if milestone was crossed
            if previous_value < milestone <= current_value:
                title = f"{kpi_name}: Milestone Reached - {milestone:,.0f}"
                description = (
                    f"{kpi_name} has crossed the {milestone:,.0f} milestone, "
                    f"reaching {current_value:,.2f}. This represents significant progress."
                )

                insights.append(
                    Insight(
                        id=f"milestone_{kpi_id}_{int(milestone)}",
                        type=InsightType.MILESTONE,
                        priority=InsightPriority.MEDIUM,
                        category=category,
                        title=title,
                        description=description,
                        kpi_id=kpi_id,
                        region_id=region_id,
                        metric_value=current_value,
                        metric_change=current_value - previous_value,
                        confidence=1.0,
                        generated_at=datetime.now(timezone.utc),
                        metadata={
                            "milestone": milestone,
                            "previous_value": previous_value,
                        },
                    )
                )

        return insights


# =============================================================================
# INSIGHT ENGINE
# =============================================================================


class InsightEngine:
    """
    Main insight engine that orchestrates all insight generators.

    Combines pattern recognition, anomaly detection, and target comparisons
    to generate prioritized, actionable insights.
    """

    def __init__(self):
        self.trend_generator = TrendInsightGenerator()
        self.anomaly_generator = AnomalyInsightGenerator()
        self.seasonality_generator = SeasonalityInsightGenerator()
        self.change_point_generator = ChangePointInsightGenerator()
        self.target_generator = TargetGapInsightGenerator()
        self.milestone_generator = MilestoneInsightGenerator()

    def generate_insights(
        self,
        kpi_id: str,
        kpi_name: str,
        category: str,
        data: pd.DataFrame,
        target_value: float | None = None,
        higher_is_better: bool = True,
        region_id: str | None = None,
    ) -> list[Insight]:
        """
        Generate all insights for a single KPI.

        Args:
            kpi_id: KPI identifier
            kpi_name: Human-readable KPI name
            category: Category (economic, environmental, social, governance)
            data: DataFrame with year, quarter, value columns
            target_value: Optional target value for comparison
            higher_is_better: Whether higher values are better
            region_id: Optional region identifier

        Returns:
            List of Insight objects
        """
        insights: list[Insight] = []

        # Map category string to enum
        try:
            cat_enum = InsightCategory(category.lower())
        except ValueError:
            cat_enum = InsightCategory.ECONOMIC

        if data.empty or len(data) < 4:
            return insights

        # Run pattern recognition
        pattern_result = analyze_patterns(data)

        # Generate trend insights
        insights.extend(
            self.trend_generator.generate(
                kpi_id, kpi_name, cat_enum, pattern_result, region_id
            )
        )

        # Generate seasonality insights
        insights.extend(
            self.seasonality_generator.generate(
                kpi_id, kpi_name, cat_enum, pattern_result, region_id
            )
        )

        # Generate change point insights
        insights.extend(
            self.change_point_generator.generate(
                kpi_id, kpi_name, cat_enum, pattern_result, region_id
            )
        )

        # Run anomaly detection
        try:
            anomaly_dicts = detect_kpi_anomalies(
                df=data,
                kpi_id=kpi_id,
                region_id=region_id or "all",
                higher_is_better=higher_is_better,
            )
            # Convert dicts back to AnomalyResult objects
            anomalies = [
                AnomalyResult(
                    kpi_id=a["kpi_id"],
                    region_id=a["region_id"],
                    year=a["year"],
                    quarter=a["quarter"],
                    actual_value=a["actual_value"],
                    expected_value=a["expected_value"],
                    deviation=a["deviation"],
                    z_score=a["z_score"],
                    severity=AnomalySeverity(a["severity"]),
                    direction=a["direction"],
                    description=a["description"],
                )
                for a in anomaly_dicts
            ]
            insights.extend(
                self.anomaly_generator.generate(
                    kpi_id, kpi_name, cat_enum, anomalies, region_id
                )
            )
        except Exception as e:
            logger.warning(f"Anomaly detection failed for {kpi_id}: {e}")

        # Generate target gap insights
        if target_value is not None:
            current_value = float(data.iloc[-1]["value"])
            insights.extend(
                self.target_generator.generate(
                    kpi_id, kpi_name, cat_enum,
                    current_value, target_value, higher_is_better, region_id
                )
            )

        # Generate milestone insights
        if len(data) >= 2:
            current_value = float(data.iloc[-1]["value"])
            previous_value = float(data.iloc[-2]["value"])
            insights.extend(
                self.milestone_generator.generate(
                    kpi_id, kpi_name, cat_enum,
                    current_value, previous_value, region_id
                )
            )

        return insights

    def generate_report(
        self,
        kpis: list[dict[str, Any]],
        period: str = "Current",
    ) -> InsightReport:
        """
        Generate a complete insight report for multiple KPIs.

        Args:
            kpis: List of KPI configurations with data
            period: Period label for the report

        Returns:
            InsightReport with all insights and summary
        """
        all_insights: list[Insight] = []

        for kpi in kpis:
            insights = self.generate_insights(
                kpi_id=kpi.get("id", "unknown"),
                kpi_name=kpi.get("name", "Unknown KPI"),
                category=kpi.get("category", "economic"),
                data=kpi.get("data", pd.DataFrame()),
                target_value=kpi.get("target"),
                higher_is_better=kpi.get("higher_is_better", True),
                region_id=kpi.get("region_id"),
            )
            all_insights.extend(insights)

        # Sort by priority
        priority_order = {
            InsightPriority.CRITICAL: 0,
            InsightPriority.HIGH: 1,
            InsightPriority.MEDIUM: 2,
            InsightPriority.LOW: 3,
            InsightPriority.INFO: 4,
        }
        all_insights.sort(key=lambda x: priority_order.get(x.priority, 5))

        # Count by priority, type, category
        by_priority = {}
        by_type = {}
        by_category = {}

        for insight in all_insights:
            by_priority[insight.priority.value] = by_priority.get(insight.priority.value, 0) + 1
            by_type[insight.type.value] = by_type.get(insight.type.value, 0) + 1
            by_category[insight.category.value] = by_category.get(insight.category.value, 0) + 1

        # Generate summary
        summary = self._generate_summary(all_insights, by_priority)

        return InsightReport(
            period=period,
            generated_at=datetime.now(timezone.utc),
            insights=all_insights,
            summary=summary,
            total_count=len(all_insights),
            by_priority=by_priority,
            by_type=by_type,
            by_category=by_category,
        )

    def _generate_summary(
        self,
        insights: list[Insight],
        by_priority: dict[str, int],
    ) -> str:
        """Generate executive summary of insights."""
        total = len(insights)
        if total == 0:
            return "No significant insights detected for this period."

        critical = by_priority.get("critical", 0)
        high = by_priority.get("high", 0)

        parts = [f"Generated {total} insights for this period."]

        if critical > 0:
            parts.append(f"{critical} critical issue(s) require immediate attention.")
        if high > 0:
            parts.append(f"{high} high-priority finding(s) identified.")

        # Add top insights summary
        if insights:
            top_insight = insights[0]
            parts.append(f"Top priority: {top_insight.title}")

        return " ".join(parts)


# =============================================================================
# CONVENIENCE FUNCTIONS
# =============================================================================


def generate_kpi_insights(
    kpi_id: str,
    kpi_name: str,
    category: str,
    data: pd.DataFrame,
    target_value: float | None = None,
    higher_is_better: bool = True,
) -> list[dict[str, Any]]:
    """
    Convenience function to generate insights for a single KPI.

    Returns list of insight dictionaries.
    """
    engine = InsightEngine()
    insights = engine.generate_insights(
        kpi_id=kpi_id,
        kpi_name=kpi_name,
        category=category,
        data=data,
        target_value=target_value,
        higher_is_better=higher_is_better,
    )
    return [i.to_dict() for i in insights]


def generate_insight_report(
    kpis: list[dict[str, Any]],
    period: str = "Current",
) -> dict[str, Any]:
    """
    Convenience function to generate a full insight report.

    Returns report dictionary.
    """
    engine = InsightEngine()
    report = engine.generate_report(kpis=kpis, period=period)
    return report.to_dict()
